<?php
/*
Plugin Name: Imagify Queue Optimizer (Off-Peak)
Description: Processes one never-attempted image per minute during a daily off-peak window. Install as MU plugin or include via theme.
Version: 0.1
Author: TJ Ops

WHY THIS EXISTS
- We want gentle, predictable Imagify optimization that won’t hammer PHP workers during business hours.
- WP-Cron runs a minute tick and, only within a daily off-peak window, asks Imagify to process a single pending attachment.
- It targets images that have NEVER been attempted by Imagify (no _imagify_status meta), so known failures/skips are not retried endlessly.

HOW TO DEPLOY
1) Copy this file to `wp-content/mu-plugins/imagify-queue-optimizer.php` (MU = always on),
   or require it from your theme’s `universal/functions/`.
2) Adjust the CONFIG section below for local time window and rate.

HOW TO VERIFY
- WP Admin → Tools → “Imagify Queue” shows counts and the last 200 log lines.
- Server: tail `wp-content/uploads/imagify-queue.log` during the window; you should see one ID per minute.

HOW TO PAUSE/ROLL BACK
- Remove the MU plugin file (or comment out the include). No DB writes beyond small log file.
*/

// CONFIG: set your local off-peak window (site time)
define( 'IQO_WINDOW_START_HOUR', 0 );    // start of window (0 = midnight)
define( 'IQO_WINDOW_DURATION_HOURS', 20 ); // run window length (hours)
define( 'IQO_ITEMS_PER_TICK', 10 );          // requested items per tick (auto-clamped)
define( 'IQO_MIN_SECONDS_BETWEEN', 5 );      // minimum spacing between items
define( 'IQO_COOLDOWN_SECONDS', 16 * 60 * 60 ); // do not re-dispatch the same ID within this window

// Add a per-minute cron schedule.
add_filter( 'cron_schedules', function ( $schedules ) {
    if ( ! isset( $schedules['every_minute'] ) ) {
        $schedules['every_minute'] = [
            'interval' => 60,
            'display'  => 'Every Minute',
        ];
    }
    return $schedules;
} );

// Ensure the ticking event is scheduled.
add_action( 'init', function () {
    if ( ! wp_next_scheduled( 'iqo_tick' ) ) {
        wp_schedule_event( time() + 60, 'every_minute', 'iqo_tick' );
    }
} );

// Helper: are we within the configured window?
function iqo_is_within_window() {
    $tz   = wp_timezone();
    $now  = new DateTime( 'now', $tz );
    $start = ( clone $now )->setTime( (int) IQO_WINDOW_START_HOUR, 0, 0 );
    $end   = ( clone $start )->modify( '+' . (int) IQO_WINDOW_DURATION_HOURS . ' hours' );

    // If start is in the future (later today), allow running only when now >= start and now < end
    return ( $now >= $start && $now < $end );
}

// Core worker used by cron and manual trigger.
function iqo_process_once( $ignore_window = false ) {
    if ( ! $ignore_window && ! iqo_is_within_window() ) {
        return 0; // outside window, do nothing
    }

    // Bail if Imagify is not active.
    if ( ! function_exists( 'imagify_async_optimize_attachment' ) && ! function_exists( 'do_action' ) ) {
        return 0;
    }

    $optimized_meta_key = '_imagify_status';

    // Auto-calc spacing and clamp items to fit within ~55s cron budget
    $requested  = max( 1, (int) IQO_ITEMS_PER_TICK );
    $spacing    = max( (int) IQO_MIN_SECONDS_BETWEEN, (int) floor( 60 / $requested ) );
    $fits       = max( 1, (int) floor( 60 / max( 1, $spacing ) ) );
    $to_process = min( $requested, $fits );

    $now_ts = time();

    $ids = get_posts( [
        'post_type'      => 'attachment',
        'post_status'    => 'inherit',
        'posts_per_page' => (int) $to_process,
        'post_mime_type' => 'image/jpeg',
        'fields'         => 'ids',
        'meta_query'     => [
            'relation' => 'AND',
            [ 'key' => $optimized_meta_key, 'compare' => 'NOT EXISTS' ],
            [
                'relation' => 'OR',
                [ 'key' => '_iqo_queued_until', 'compare' => 'NOT EXISTS' ],
                [ 'key' => '_iqo_queued_until', 'value' => $now_ts, 'compare' => '<', 'type' => 'NUMERIC' ],
            ],
        ],
    ] );

    if ( empty( $ids ) ) {
        // No more qualifying items: mark a completion tick.
        iqo_log_csv( 'COMPLETE', 'complete' );
        return 0; // Nothing to do
    }

    $done = 0;
    $started = time();
    $budget  = 55; // keep under a minute for WP-Cron safety

    foreach ( $ids as $index => $id ) {
        if ( function_exists( 'imagify_async_optimize_attachment' ) ) {
            imagify_async_optimize_attachment( (int) $id );
        } else {
            do_action( 'imagify_optimize_attachment', (int) $id );
        }
        // Mark queued cooldown to avoid duplicates while Imagify updates status
        update_post_meta( (int) $id, '_iqo_queued_until', $now_ts + (int) IQO_COOLDOWN_SECONDS );
        $done++;

        // Log dispatch to CSV immediately; completion (if hooked) is logged separately.
        iqo_log_csv( (int) $id, 'dispatched' );

        // Optional spacing between items, but respect total time budget.
        if ( $spacing > 0 && ( time() - $started ) + $spacing < $budget && $index < ( count( $ids ) - 1 ) ) {
            sleep( $spacing );
        }
    }
    return $done;
}

// Tick handler: process up to N unoptimized attachments.
add_action( 'iqo_tick', function () { iqo_process_once( false ); } );

// Small CSV logger helpers (writes to logs-universal at theme root)
function iqo_machine_tag() {
    // Prefer hostname; fallback to site host. Sanitize to [a-z0-9-]
    $host = php_uname('n');
    if ( ! $host || $host === 'Unknown' ) {
        $parsed = wp_parse_url( home_url() );
        $host = $parsed['host'] ?? 'unknown';
    }
    $tag = strtolower( preg_replace( '/[^a-zA-Z0-9\-]+/', '-', $host ) );
    return trim( $tag, '-' );
}

function iqo_log_path() {
    $theme_dir = get_stylesheet_directory();
    // Theme dir already ends with /themes/universal — don't duplicate 'universal'
    $dir = trailingslashit( $theme_dir ) . 'logs-universal';
    if ( ! is_dir( $dir ) ) {
        @wp_mkdir_p( $dir );
    }
    $suffix = iqo_machine_tag();
    return $dir . '/imagify-queue-' . $suffix . '.csv';
}

// Current Eastern Time timestamp for human readability: mm-dd-yy_HH-mm (24h)
function iqo_now_et_stamp() {
    try {
        $tz   = new DateTimeZone( 'America/New_York' );
        $dt   = new DateTime( 'now', $tz );
        // PHP: H = 24h hour, i = minutes
        return $dt->format( 'm-d-y_H-i-s' );
    } catch ( Exception $e ) {
        return gmdate( 'm-d-y_H-i-s' );
    }
}

function iqo_attachment_relpath( $attachment_id ) {
    $file = get_attached_file( (int) $attachment_id );
    if ( ! $file ) { return ''; }
    $uploads = wp_upload_dir();
    if ( ! empty( $uploads['basedir'] ) && str_starts_with( $file, $uploads['basedir'] ) ) {
        $rel = '/wp-content/uploads' . substr( $file, strlen( $uploads['basedir'] ) );
        return str_replace( '\\', '/', $rel );
    }
    return $file;
}

function iqo_log_csv( $id, $result ) {
    $file = iqo_log_path();
    $is_new = ! file_exists( $file );
    // Ensure directory exists/writable
    $dir = dirname( $file );
    if ( ! is_dir( $dir ) ) {
        @wp_mkdir_p( $dir );
    }
    // Build new line content first (two columns only: datetime_et, attachment_id)
    $stamp = iqo_now_et_stamp();
    if ( $id === 'COMPLETE' ) {
        $new_line = $stamp . ',COMPLETE' . "\n";
    } else {
        $rel = iqo_attachment_relpath( (int) $id );
        // datetime, id, relative_path
        $new_line = $stamp . ',' . (string) (int) $id . ',' . $rel . "\n";
    }

    if ( $is_new ) {
        // Create with just the first line; no header per preference.
        @file_put_contents( $file, $new_line, LOCK_EX );
    } else {
        // Prepend newest entry and trim to last 1000 lines
        $existing = @file( $file, FILE_IGNORE_NEW_LINES );
        if ( ! is_array( $existing ) ) { $existing = []; }
        array_unshift( $existing, rtrim( $new_line, "\n" ) );
        $existing = array_slice( $existing, 0, 1000 );
        @file_put_contents( $file, implode( "\n", $existing ) . "\n", LOCK_EX );
    }

    // Nothing else to do
}

// Log completion if Imagify fires a hook we can catch.
add_action( 'imagify_optimization_complete', function( $attachment_id, $data = [] ) {
    iqo_log_csv( (int) $attachment_id, 'completed' );
}, 10, 2 );

// Admin helper: reset cooldown so queue can re-attempt immediately.
// Visit: /wp-admin/?iqo=reset_cooldown&_wpnonce=... (nonce: iqo_reset_cooldown)
add_action( 'admin_init', function () {
    if ( ! is_admin() || ! current_user_can( 'manage_options' ) ) {
        return;
    }
    if ( isset( $_GET['iqo'] ) && $_GET['iqo'] === 'reset_cooldown' ) {
        if ( ! isset( $_GET['_wpnonce'] ) || ! wp_verify_nonce( $_GET['_wpnonce'], 'iqo_reset_cooldown' ) ) {
            wp_die( 'Invalid nonce for cooldown reset.' );
        }
        // Delete _iqo_queued_until from all JPEG attachments.
        $paged = 1;
        $total = 0;
        do {
            $ids = get_posts([
                'post_type'      => 'attachment',
                'post_status'    => 'inherit',
                'post_mime_type' => 'image/jpeg',
                'fields'         => 'ids',
                'posts_per_page' => 500,
                'paged'          => $paged,
                'meta_query'     => [[ 'key' => '_iqo_queued_until', 'compare' => 'EXISTS' ]],
            ]);
            foreach ( $ids as $id ) {
                delete_post_meta( (int) $id, '_iqo_queued_until' );
                $total++;
            }
            $paged++;
        } while ( ! empty( $ids ) );

        // Log a reset marker and show an admin notice.
        iqo_log_csv( 'COMPLETE', 'reset_cooldown' );
        add_action( 'admin_notices', function () use ( $total ) {
            echo '<div class="notice notice-success"><p>Imagify Queue: cooldown reset for ' . (int) $total . ' JPEG attachments. Queue will re-run on next tick.</p></div>';
        } );
    }
} );

// Admin page: Tools → Imagify Queue Log (simple viewer)
// Admin page enabled until CSV path + download verified
// Admin page enabled for local testing (reset cooldown, manual run, CSV)
// Admin page enabled under Media → Imagify Queue (reset cooldown, run once, CSV)
add_action( 'admin_menu', function () {
    // Move under Media menu; use 'upload_files' capability so editors with media access can view
    add_media_page( 'Imagify Queue Log', 'Imagify Queue', 'upload_files', 'imagify-queue-log', function () {
        // Manual trigger for testing/local
        if ( isset( $_GET['iqo'] ) && $_GET['iqo'] === 'run_once' && current_user_can( 'manage_options' ) && check_admin_referer( 'iqo_run_once' ) ) {
            $count = iqo_process_once( true );
            echo '<div class="notice notice-success"><p>Imagify Queue: ran once (forced). Items dispatched: ' . (int) $count . '.</p></div>';
        }
        echo '<div class="wrap"><h1>Imagify Queue</h1>';

        // Summary counters
        $counts = [ 'images_total' => 0, 'never_attempted' => 0, 'optimized_success' => 0, 'attempted_not_success' => 0 ];

        if ( function_exists( 'wp_count_attachments' ) ) {
            $c = wp_count_attachments( 'image' );
            if ( isset( $c->inherit ) ) {
                $counts['images_total'] = (int) $c->inherit;
            }
        }

        $optimized_meta_key = '_imagify_status';

        // never attempted (no status meta)
        $q = new WP_Query([
            'post_type'      => 'attachment',
            'post_status'    => 'inherit',
            'post_mime_type' => 'image',
            'fields'         => 'ids',
            'posts_per_page' => 1,
            'meta_query'     => [[ 'key' => $optimized_meta_key, 'compare' => 'NOT EXISTS' ]],
            'no_found_rows'  => false,
        ]);
        $counts['never_attempted'] = (int) $q->found_posts;

        // success
        $q = new WP_Query([
            'post_type'      => 'attachment',
            'post_status'    => 'inherit',
            'post_mime_type' => 'image',
            'fields'         => 'ids',
            'posts_per_page' => 1,
            'meta_query'     => [[ 'key' => $optimized_meta_key, 'value' => 'success', 'compare' => '=' ]],
            'no_found_rows'  => false,
        ]);
        $counts['optimized_success'] = (int) $q->found_posts;

        // attempted but not success (treat as failures or skipped)
        $q = new WP_Query([
            'post_type'      => 'attachment',
            'post_status'    => 'inherit',
            'post_mime_type' => 'image',
            'fields'         => 'ids',
            'posts_per_page' => 1,
            'meta_query'     => [[ 'key' => $optimized_meta_key, 'value' => 'success', 'compare' => '!=' ]],
            'no_found_rows'  => false,
        ]);
        $counts['attempted_not_success'] = (int) $q->found_posts;

        echo '<p><strong>Summary</strong></p>';
        echo '<ul>';
        printf( '<li>Total images: %d</li>', $counts['images_total'] );
        printf( '<li>Never attempted: %d</li>', $counts['never_attempted'] );
        printf( '<li>Optimized (success): %d</li>', $counts['optimized_success'] );
        printf( '<li>Attempted but not success (errors/skips): %d</li>', $counts['attempted_not_success'] );
        echo '</ul>';

        $url = wp_nonce_url( admin_url( 'tools.php?page=imagify-queue-log&iqo=run_once' ), 'iqo_run_once' );
        echo '<p><a class="button button-primary" href="' . esc_url( $url ) . '">Run one now (ignore window)</a></p>';

        // CSV download
        if ( isset( $_GET['download'] ) && $_GET['download'] === 'csv' && current_user_can( 'manage_options' ) ) {
            $file = iqo_log_path();
            if ( file_exists( $file ) && ! headers_sent() ) {
                header( 'Content-Type: text/csv' );
                header( 'Content-Disposition: attachment; filename="imagify-queue.csv"' );
                readfile( $file );
                exit;
            }
        }

        // Resolve machine-specific log; fall back to any imagify-queue-*.csv if current host file not found
        $file = iqo_log_path();
        if ( ! file_exists( $file ) ) {
            $dir  = dirname( $file );
            $list = glob( $dir . '/imagify-queue-*.csv' );
            if ( is_array( $list ) && count( $list ) === 1 ) {
                $file = $list[0];
            }
        }
        echo '<h2>Recent Log</h2><p>Shows the last 1000 lines from <code>' . esc_html( str_replace( ABSPATH, '/', $file ) ) . '</code></p>';
        echo '<p><a class="button" href="' . esc_url( admin_url( 'tools.php?page=imagify-queue-log&download=csv' ) ) . '">Download CSV</a> ';
        $reset_url = wp_nonce_url( admin_url( '?iqo=reset_cooldown' ), 'iqo_reset_cooldown' );
        echo '<a class="button button-link-delete" href="' . esc_url( $reset_url ) . '" onclick="return confirm(\'Reset cooldown for all JPEGs?\');">Reset cooldown</a></p>';
        if ( file_exists( $file ) ) {
            $lines = @file( $file );
            if ( $lines ) {
                $tail = array_slice( $lines, -1000 );
                echo '<pre style="max-height:400px;overflow:auto;background:#111;color:#0f0;padding:12px;">' . esc_html( implode( '', $tail ) ) . '</pre>';
            } else {
                echo '<p>No log entries found.</p>';
            }
        } else {
            echo '<p>Log file not created yet.</p>';
        }
        echo '</div>';
    } );
} );
<?php
/*
WIP: Imagify Queue Optimizer — Notes
Date: 2025-09-12 11:27 (local)

Status
- This file is intentionally renamed with `_work_in_progress_091225_1127` so it does not execute.
- Active implementation currently lives in: `universal/functions/imagify-queue-optimizer.php`.
- CSV logging, pacing, window control, and cooldown are validated on local.

What works (in active file)
- Window: configurable; currently 00:00–20:00 for local testing.
- Pacing: 1 per minute (auto‑spaced; clamped to ~55s per tick).
- Cooldown: 24h per image (`_iqo_queued_until`) to prevent duplicate dispatch.
- Logging: machine‑specific CSV at `universal/logs-universal/imagify-queue-{hostname}.csv`.
- Admin page (optional): Media → Imagify Queue (Run once, Download CSV, Reset cooldown).

What’s still pending before production
- File‑mode (Other Media) dispatch: target JPEGs in `/wp-content/themes/universal` and `/wp-content/gallery` (NextGEN) using Imagify’s file API.
- Retry policy: optionally queue attachments with `_imagify_status != success` (errors only) — keep cooldown.
- Completion signals for file‑mode: add a `completed` line when Imagify reports done for raw file paths.

Quick resume checklist
1) Implement a file dispatcher (JPEG/JPG only, exclude `*_backup` and all `.webp`).
2) Add per‑file cooldown meta (or local index) to avoid repeats while status updates.
3) Keep current window and 1/min pacing; confirm no PHP worker pressure.
4) Validate by watching CSV and Imagify UI; revert window to 4h for production.

Reference
- Logs: `universal/logs-universal/imagify-queue-*.csv`
- Admin reset URL (when UI enabled): `/wp-admin/upload.php?page=imagify-queue-log`
- Cooldown explanation: per‑image hold so the same item isn’t dispatched multiple times before Imagify saves status.
*/

// (No executable code in this WIP file.)
